//---------------------------------------------------------------------------

#include <System.hpp>
#pragma hdrstop

#include "ProcessThread.h"
#pragma package(smart_init)
//---------------------------------------------------------------------------

//   Important: Methods and properties of objects in VCL can only be
//   used in a method called using Synchronize, for example:
//
//      Synchronize(&UpdateCaption);
//
//   where UpdateCaption could look like:
//
//      void __fastcall ProcessThread::UpdateCaption()
//      {
//        Form1->Caption = "Updated in a thread";
//      }
//---------------------------------------------------------------------------

__fastcall ProcessThread::ProcessThread(bool CreateSuspended, TEvent* MyEvent, DWORD bufferSize, TForm1* Form1, bool useSignatureSearch)
 : TThread(CreateSuspended), MyEvent(MyEvent), bufferSize(bufferSize), Form1(Form1), useSignatureSearch(useSignatureSearch)
{
	FreeOnTerminate = true; // очистка при завершении
	receivedBuffer = new char[bufferSize];  // выделение памяти
	copyBuffer = new char[bufferSize];
}
//---------------------------------------------------------------------------
void __fastcall ProcessThread::Execute()
{
	//---- Place thread code here ----
	while (!Terminated)
	{
		// Проверяем установлен ли флаг (с ожиданием в 0 мс)
		if (MyEvent->WaitFor(0) == wrSignaled)
		{
			// Копируем буфер
			memcpy(copyBuffer, receivedBuffer, bufferSize);

			// Сбрасываем флаг события, чтобы ReadThread продолжил читать
			MyEvent->ResetEvent();

			// Работаем с copyBuffer
			if (useSignatureSearch) {
				clusterSignature = FindSignature(copyBuffer, Form1->SelectedSignatures);
				if (clusterSignature == NULL) {
					continue;
				}
			}

			// Вставка данных в БД
			addClusterToDB();
		}
	}

	Synchronize(&addClustersToVST);

	delete[] receivedBuffer, copyBuffer;
}
//---------------------------------------------------------------------------

bool ProcessThread::addClusterToDB() {
	// Шаг 1 (подготовка запроса)
	const char* errmsg;
	sqlite3_stmt* pStatement;

	// Формируем запросы
	wchar_t sql[] = L"INSERT INTO scans (cluster_number, cluster_content, signature) VALUES (?, ?, ?);";

	int result = sqlite3_prepare16_v2(Form1->Database, sql, -1, &pStatement, NULL);
	if (result != SQLITE_OK) {
		errmsg = sqlite3_errmsg(Form1->Database);
		ShowMessage(L"Ошибка при выполнении INSERT для таблицы scans: " + UnicodeString(errmsg));
		// Шаг 3 (завершение обработки запроса)
		sqlite3_finalize(pStatement);
		return false;
	}

	// Подставляем значения вместо ?, ?, ?
	result = sqlite3_bind_int64(pStatement, 1, clusterNumber);
	if (result != SQLITE_OK) {
		errmsg = sqlite3_errmsg(Form1->Database);
		ShowMessage(L"Ошибка при выполнении INSERT для таблицы scans: " + UnicodeString(errmsg));
		// Шаг 3 (завершение обработки запроса)
		sqlite3_finalize(pStatement);
		return false;
	}

	result = sqlite3_bind_blob(pStatement, 2, copyBuffer, bufferSize, SQLITE_STATIC);
	if (result != SQLITE_OK) {
		errmsg = sqlite3_errmsg(Form1->Database);
		ShowMessage(L"Ошибка при выполнении INSERT для таблицы scans: " + UnicodeString(errmsg));
		// Шаг 3 (завершение обработки запроса)
		sqlite3_finalize(pStatement);
		return false;
	}


	result = sqlite3_bind_text(pStatement, 3, GetSignatureName(clusterSignature), -1, SQLITE_STATIC);
	if (result != SQLITE_OK) {
		errmsg = sqlite3_errmsg(Form1->Database);
		ShowMessage(L"Ошибка при выполнении INSERT для таблицы scans: " + UnicodeString(errmsg));
		// Шаг 3 (завершение обработки запроса)
		sqlite3_finalize(pStatement);
		return false;
	}

	// Шаг 2 (выполнение запроса)
	result = sqlite3_step(pStatement);

	// Проверяем результат
	if (result != SQLITE_DONE) {
		errmsg = sqlite3_errmsg(Form1->Database);
		ShowMessage(L"Ошибка при выполнении INSERT для таблицы scans: " + UnicodeString(errmsg));

		// Шаг 3 (завершение обработки запроса)
		sqlite3_finalize(pStatement);
		return false;
	}

	// Шаг 3 (завершение обработки запроса)
	sqlite3_finalize(pStatement);

	return true;
}

void  __fastcall ProcessThread::addClustersToVST() {
	TVirtualStringTree* VST = Form1->VirtualStringTree1;

	// Шаг 1 (подготовка запроса)
	const char *errmsg;
	sqlite3_stmt *pStatement;

	// Формируем запрос с фильтрацией кластера по сигнатуре
	wchar_t sql[] = L"SELECT id, cluster_number, cluster_content, signature FROM scans;";

	int result = sqlite3_prepare16_v2(Form1->Database, sql, -1, &pStatement, NULL);

	if (result == SQLITE_OK) {
		VST->Clear();
		VST->BeginUpdate();

		// Шаг 2 (выполнение запроса и получение результата для множества строк)
		while (true) {
			result = sqlite3_step(pStatement);
			if(result != SQLITE_ROW) break;

			PVirtualNode entryNode = VST->AddChild(VST->RootNode);
			ScansTableStruct* nodeData = (ScansTableStruct*) VST->GetNodeData(entryNode);

			nodeData->Id = sqlite3_column_int64(pStatement, 0);
			nodeData->ClusterNumber = sqlite3_column_int64(pStatement, 1);
			nodeData->ClusterContent = UnicodeString(
					(char*) sqlite3_column_blob(pStatement, 2), // содержимое кластера
					sqlite3_column_bytes(pStatement, 2) // кол-во байт, которые нужно прочитать в содержимом
			);
			nodeData->Signature = UnicodeString((char*)sqlite3_column_text(pStatement, 3));
		}

		VST->EndUpdate();
	} else {
		errmsg = sqlite3_errmsg(Form1->Database);
		ShowMessage(L"Ошибка при выполнении SELECT для таблицы scans: " + UnicodeString(errmsg));
	}

	// Шаг 3 (завершение обработки запроса)
	sqlite3_finalize(pStatement);
}


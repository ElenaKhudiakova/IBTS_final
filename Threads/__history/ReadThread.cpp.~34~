//---------------------------------------------------------------------------

#include <System.hpp>
#pragma hdrstop

#include "ReadThread.h"
#pragma package(smart_init)
//---------------------------------------------------------------------------

//   Important: Methods and properties of objects in VCL can only be
//   used in a method called using Synchronize, for example:
//
//      Synchronize(&UpdateCaption);
//
//   where UpdateCaption could look like:
//
//      void __fastcall ReadThread::UpdateCaption()
//      {
//        Form1->Caption = "Updated in a thread";
//      }
//---------------------------------------------------------------------------

__fastcall ReadThread::ReadThread(bool CreateSuspended, IteratorFS* Iterator, TForm1* Form1, bool useSignatureSearch)
	: TThread(CreateSuspended), Iterator(Iterator), Form1(Form1)
{
	FreeOnTerminate = true; // при создании потока включаем параметр, чтобы при удалении потока было самостоятельное очищение
	this->MyEvent = new TEvent(NULL, true, false, "", false);   // this используем для ссылки на самих себя, для однозначного определения
	this->ProcessThreadPtr = new ProcessThread(true, MyEvent, Iterator->GetFileSystem()->GetClusterSize(), Form1, useSignatureSearch);
}
// TEvent(NULL, true, false, "", false) взята из лекции
//---------------------------------------------------------------------------
void __fastcall ReadThread::Execute()
{
	//---- Place thread code here ----
	Synchronize(&OnStart);
	ProcessThreadPtr->Start();

	for (Iterator->First(); !Iterator->IsDone(); Iterator->Next()) {
		if (Terminated) break;

		// Передаём второму потоку считанный кластер
		ProcessThreadPtr->receivedBuffer = Iterator->GetCurrent();
		ProcessThreadPtr->clusterNumber = Iterator->GetCurrentPosition();

		Synchronize(&OnProgress);

		// Поднимаем флажок (второй поток начинает обрабатывать полученный кластер)
		MyEvent->SetEvent();

		// Беск цикл - ожидаем снятия флажка (MyEvent->ResetEvent) от второго потока
		while (MyEvent->WaitFor(0) == wrSignaled)
		{
			// Если работу потока завершили принудительно из формы
			if(Terminated) break;
		}
	}

	ProcessThreadPtr->Terminate();

	Synchronize(&OnStop);
	ProcessThreadPtr->WaitFor();

	delete ProcessThreadPtr;
}
//---------------------------------------------------------------------------

void __fastcall ReadThread::OnStart() {
	Form1->DeleteAllButton->Enabled = false;
	Form1->DeleteButton->Enabled = false;
	Form1->EmptyClusterToggleSwitch->Enabled = false;
	Form1->SearchSignToggleSwitch->Enabled = false;
}

void __fastcall ReadThread::OnProgress() {
	Form1->ProgressBar1->Position = Iterator->GetCurrentPosition();
	Form1->ProgressLabel->Caption = UnicodeString(Iterator->GetCurrentPosition());
// попытка сделать прогресс в процентах
//	Form1->ProgressLabel->Caption = UnicodeString(
//			100
//			*(float)(Iterator->currentPosition+1)
//			/(float)(Iterator->FileSystem->GetClusterCount())
//	) + L"%";
}

void __fastcall ReadThread::OnStop() {
	Form1->ProgressBar1->Position = Form1->ProgressBar1->Max;   // заполнить до конца
	Form1->ProgressLabel->Caption = Iterator->GetFileSystem()->GetClusterCount(); // указать последнее число кластеров
	Form1->ScanToggleSwitch->State = tssOff;    // выключить  Switch, то есть кнопку на форме "СКАНИРОВАТЬ"
	Form1->DeleteAllButton->Enabled = true;  // вклюить кнопки удаления записей
	Form1->DeleteButton->Enabled = true;
	Form1->EmptyClusterToggleSwitch->Enabled = true;  // активировать кнопки на сканирование
	Form1->SearchSignToggleSwitch->Enabled = true;
}

//---------------------------------------------------------------------------
#ifndef AbstractFileSystemH
#define AbstractFileSystemH
#include <vcl.h>
//---------------------------------------------------------------------------

class IteratorFS {
	protected:
		class AbstractFileSystem* FileSystem;
		DWORD currentPosition;   // DWORD - 32-битное беззнаковое целое
		char* clusterBuffer;     // Целочисленный (символьный) тип данных
		bool done;               // Логический тип данных bool, правда/ложь
	public:
		IteratorFS(AbstractFileSystem* FileSystem);

		virtual void First();   // Отсроченный метод, так как используются виртуальные функции
		virtual void Next();
		virtual bool IsDone();
		virtual char* GetCurrent();
		virtual DWORD GetCurrentPosition();
		virtual AbstractFileSystem* GetFileSystem();

		~IteratorFS();   // Побитовая инверсия (НЕ)      ПОЧЕМУ????
};

// Абстрактный класс
// Public — доступ открыт всем другим классам, кто видит определение данного класса.
// Protected — доступ открыт классам, производным от данного. То есть, производные классы получают свободный доступ
// к таким свойствам или метода. Все другие классы такого доступа не имеют.
// Private — доступ открыт самому классу (т.е. функциям-членам данного класса) и друзьям (friend) данного класса -
// как функциям, так и классам. Однако производные классы не получают доступа к этим данным совсем.
// И все другие классы такого доступа не имеют.
class AbstractFileSystem {
	private:
		HANDLE FileHandle;
	protected:    // поля/переменные доступны из наследников (применяем, чтобы избежать перезаписи значений)
		UINT64 fileSystemSize; // UINT64 = unsigned __int64
		DWORD clusterCount;
		DWORD clusterSize;    // 	DWORD = unsigned long

		// Конструктор
		// protected, потому что ФС на данном этапе только абстрактная
		AbstractFileSystem(HANDLE FileHandle);

	public:   //   public для свободного обращения из других кодов
		// Размер файловой системы (в байтах)
		UINT64 GetFileSystemSize();
		// Количество кластеров в файловой системе
		DWORD GetClusterCount();
		// Размер кластера файловой системы (в байтах)
		DWORD GetClusterSize();

		// Метод создания итератора (чистый метод)
		virtual IteratorFS* GetIterator() = 0; // 0, потому что нет текущей реализации (0 - pure-specifier, чистый)

		// Абстрактный метод чтения кластера
		virtual bool ReadCluster(char* dataBuffer, DWORD clusterNumber); // нет 0, так как реализуется в AbstractFileSystem.cpp

		// Деструктор
		~AbstractFileSystem();
};

#endif

//---------------------------------------------------------------------------

#pragma hdrstop

#include "NoEmptyClusterDecorator.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)

NoEmptyClusterDecorator::NoEmptyClusterDecorator(IteratorFS* Iterator)
	: IteratorFS(Iterator->GetFileSystem()), Iterator(Iterator)
{

}

// Переопределённый метод First() от IteratorFS
void NoEmptyClusterDecorator::First() {
	Iterator->First();

	while (true) {
		// Если не удалось прочитать, то завершаем работу
		if (Iterator->IsDone()) {
			return;
		}

		// Получаем текущий кластер
		char* clusterBuffer = Iterator->GetCurrent();

		// Проверяем
		// Если начало кластера пустое, то считаем, что весь кластер пустой (лекция)
		if (clusterBuffer[0] == 0x00) {
			// Если кластер нулевой, то читаем следующий кластер с помощью функции  Next
			Iterator->Next();
		} else {
			break;
		}
	}
}    // Если кластер не пустой, то завершается работа функции First

void NoEmptyClusterDecorator::Next() {
	Iterator->Next();

	while (true) {
		// Если не удалось прочитать, то завершаем работу
		if (Iterator->IsDone()) {
			return;
		}

		// Получаем текущий кластер
		char* clusterBuffer = Iterator->GetCurrent();

		// Проверяем
		// Если начало кластера пустое, то считаем, что весь кластер пустой
		if (clusterBuffer[0] == 0x00) {
			// Читаем следующий кластер
			Iterator->Next();
		} else {
			break;
		}
	}
}

//Обращаемся к переданному итератору

bool NoEmptyClusterDecorator::IsDone() {
	return Iterator->IsDone();
}

char* NoEmptyClusterDecorator::GetCurrent() {
	return Iterator->GetCurrent();
}

DWORD NoEmptyClusterDecorator::GetCurrentPosition() {
	return Iterator->GetCurrentPosition();
}

AbstractFileSystem* NoEmptyClusterDecorator::GetFileSystem() {
	return Iterator->GetFileSystem();
}


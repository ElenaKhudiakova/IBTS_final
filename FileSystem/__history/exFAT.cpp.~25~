//---------------------------------------------------------------------------

#pragma hdrstop

#include "exFAT.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)

exFAT::exFAT(HANDLE FileHandle)
	: AbstractFileSystem(FileHandle) {
	char dataBuffer[512];
	// Позиционируемся в файле
	LARGE_INTEGER sectorOffset;       // LARGE_INTEGER - 64-разрядное целое значение со знаком
	// Смещение от начала кластера
	sectorOffset.QuadPart = 0;

	// Задаём позицию

	 // Члены структуры:
// LowPart	Определяет младшее 32 бита
// HighPart	Определяет старшие 32
// QuadPart	Определяет 64-х битное знаковое целое
	DWORD currentPosition = SetFilePointer(
		FileHandle,
		sectorOffset.LowPart,
		&sectorOffset.HighPart,
		FILE_BEGIN
	);

	if (currentPosition != sectorOffset.LowPart) {
		return;
	}

	DWORD bytesToRead = 512;				// Сколько байтов нужно прочитать
	DWORD bytesRead; 	    				// Сколько байтов удалось считать

	// Чтение данных
	bool readResult = ReadFile(
		FileHandle,
		dataBuffer,
		bytesToRead,
		&bytesRead,
		NULL
	);

	if (readResult && bytesRead == bytesToRead) {
		exFAT_BootRecord* exfatBR = (exFAT_BootRecord*) dataBuffer;
		clusterCount = (DWORD)(exfatBR->ClusterCount);
		clusterSize = (DWORD)(
				pow((double)2, exfatBR->BytesPerSectorShift)        //	pow - возведение в степень
				* pow((double)2, exfatBR->SectorsPerClusterShift)
		);
		fileSystemSize = (UINT64)(clusterCount*clusterSize);
	}
}

// В зависимости от main.h "class AbstractFileSystem* FileSystem" вызывается метод exFATIterator
IteratorFS* exFAT::GetIterator() {
	return new exFATIterator(this);
}
// создается уникальный итератор для каждой ФС

exFATIterator::exFATIterator(AbstractFileSystem* FileSystem)
	: IteratorFS(FileSystem)
{

}
